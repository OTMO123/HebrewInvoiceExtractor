# -*- coding: utf-8 -*-
"""RAW_AI_UPDATER.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dg9epmYk7erpPcWHCUAbr-DxtJr1idkb

# Новый раздел
"""

!pip install anthropic
!pip install pdf2image
!pip install PyPDF2
!pip install fuzzywuzzy
!pip install python-Levenshtein
!pip install pillow
!pip install openai
!pip install openpyxl
import os
import base64
import json
import time
import tempfile
import re
from typing import List, Dict, Any, Optional, Tuple
import pandas as pd
import io
from google.colab import files
from anthropic import Anthropic
from pdf2image import convert_from_path
from PIL import Image
import numpy as np
from PyPDF2 import PdfReader, PdfWriter
import math
from fuzzywuzzy import fuzz, process

class EnhancedInvoiceProcessor:
    def __init__(self, api_key):
        """
        Инициализирует улучшенный процессор счетов с API ключом Anthropic

        Args:
            api_key (str): API ключ Anthropic
        """
        self.api_key = api_key
        self.client = Anthropic(api_key=api_key)
        # Создаем словарь соответствий для известных продуктов (можно расширять)
        self.product_mapping = {
            # Словарь для часто встречающихся продуктов
            'עגבניות': 'tomatoes',
            'מלפפון': 'cucumber',
            'גזר': 'carrot',
            'תפוח אדמה': 'potato',
            'בצל': 'onion',
            'פלפל': 'pepper',
            'חסה': 'lettuce',
            'חלב': 'milk',
            'גבינה': 'cheese',
            'יוגורט': 'yogurt',
            'ביצים': 'eggs',
            'עוף': 'chicken',
            'בשר בקר': 'beef',
            'דג': 'fish',
            'לחם': 'bread',
            'אורז': 'rice',
            'פסטה': 'pasta',
            'קמח': 'flour',
            'סוכר': 'sugar',
            'שמן': 'oil',
            'מלח': 'salt',
            'פירות': 'fruits',
            'ירקות': 'vegetables',
            'תבלינים': 'spices',
            'דבש': 'honey',
            'טחינה': 'tahini',
            'חומוס': 'hummus',
            'זיתים': 'olives'
        }

        # Ключевые слова для предварительной проверки документов на наличие продуктов питания
        self.food_keywords_hebrew = [
            'מזון', 'אוכל', 'מכולת', 'סופרמרקט', 'ירקות', 'פירות', 'בשר', 'דגים',
            'מוצרי חלב', 'לחם', 'קמח', 'סוכר', 'שמן', 'תבלינים', 'משקאות',
            'ק"ג', 'גרם', 'ליטר', 'חתיכה', 'יחידה', 'מחיר', 'כמות'
        ]

        # Создаем список слов, которые указывают на непродуктовые документы
        self.non_food_keywords = [
            'פנגו', 'חניה', 'parking', 'fedex', 'shipping', 'invoice', 'tax',
            'שילוח', 'screws', 'washers', 'בורג', 'מיקרוביולוגיה'
        ]

        # Все обнаруженные продукты будут сохраняться здесь
        self.all_products = []

        # Статистика по страницам
        self.page_statistics = {}

        # Счетчик пропущенных документов
        self.skipped_count = 0

    def split_pdf(self, input_pdf_path: str, output_folder: str, pages_per_chunk: int = 5) -> List[str]:
        """
        Разделяет PDF файл на несколько частей с указанным количеством страниц в каждой

        Args:
            input_pdf_path (str): Путь к исходному PDF файлу
            output_folder (str): Папка для сохранения частей PDF
            pages_per_chunk (int): Количество страниц в каждой части

        Returns:
            List[str]: Список путей к созданным частям PDF
        """
        # Создаем папку, если она не существует
        os.makedirs(output_folder, exist_ok=True)

        # Открываем исходный PDF
        pdf_reader = PdfReader(input_pdf_path)
        total_pages = len(pdf_reader.pages)

        # Определяем количество частей
        num_chunks = math.ceil(total_pages / pages_per_chunk)

        # Имя базового файла без расширения
        base_filename = os.path.splitext(os.path.basename(input_pdf_path))[0]

        # Создаем список для хранения путей к частям
        chunk_paths = []

        print(f"Разделение PDF на {num_chunks} частей по {pages_per_chunk} страниц в каждой...")

        # Создаем каждую часть
        for i in range(num_chunks):
            # Определяем диапазон страниц для текущей части
            start_page = i * pages_per_chunk
            end_page = min((i + 1) * pages_per_chunk, total_pages)

            # Создаем новый PDF файл
            pdf_writer = PdfWriter()

            # Добавляем страницы в новый PDF
            for page_num in range(start_page, end_page):
                pdf_writer.add_page(pdf_reader.pages[page_num])

            # Определяем путь для сохранения части
            chunk_path = os.path.join(output_folder, f"{base_filename}_part_{i+1}_{start_page+1}-{end_page}.pdf")

            # Сохраняем часть
            with open(chunk_path, "wb") as output_file:
                pdf_writer.write(output_file)

            # Добавляем путь в список
            chunk_paths.append(chunk_path)

            print(f"Создана часть {i+1}/{num_chunks}: страницы {start_page+1}-{end_page} -> {chunk_path}")

        return chunk_paths

    def convert_pdf_to_images(self, pdf_path: str, max_pages: Optional[int] = None, dpi: int = 300) -> List[Tuple[Image.Image, int]]:
        """
        Конвертирует PDF файл в список изображений с высоким разрешением

        Args:
            pdf_path (str): Путь к PDF файлу
            max_pages (Optional[int]): Максимальное количество страниц для обработки
            dpi (int): Разрешение изображения в DPI (выше для лучшего распознавания)

        Returns:
            List[Tuple[Image.Image, int]]: Список кортежей (изображение, номер страницы)
        """
        print(f"Конвертация PDF в изображения: {pdf_path}")

        # Конвертируем PDF в изображения с заданным DPI
        images = convert_from_path(pdf_path, dpi=dpi)

        # Получаем информацию о диапазоне страниц из имени файла
        start_page = 1
        try:
            if "_part_" in pdf_path and "-" in pdf_path:
                parts = os.path.basename(pdf_path).split("_part_")[1]
                page_range = parts.split("_")[1].split(".")[0]
                start_page = int(page_range.split("-")[0])
        except:
            start_page = 1

        # Создаем список кортежей (изображение, номер страницы)
        images_with_page_numbers = []
        for i, img in enumerate(images):
            page_number = start_page + i
            images_with_page_numbers.append((img, page_number))

        # Если задано максимальное количество страниц, ограничиваем список
        if max_pages and len(images_with_page_numbers) > max_pages:
            print(f"PDF содержит {len(images)} страниц. Обрабатываем только первые {max_pages}.")
            images_with_page_numbers = images_with_page_numbers[:max_pages]
        else:
            print(f"PDF содержит {len(images)} страниц.")

        return images_with_page_numbers

    def encode_image_to_base64(self, image: Image.Image, format: str = "JPEG", quality: int = 95) -> str:
        """
        Кодирует изображение в base64 для отправки через API
        с высоким качеством для лучшего распознавания

        Args:
            image (Image.Image): Изображение
            format (str): Формат изображения (JPEG, PNG, WebP)
            quality (int): Качество (для JPEG и WebP)

        Returns:
            str: Изображение в формате base64
        """
        # Создаем буфер для сохранения изображения
        buffered = io.BytesIO()

        # Проверяем размер изображения
        width, height = image.size
        max_dimension = 4000  # Максимальная ширина или высота (увеличено для лучшего качества)

        # Если изображение слишком большое, уменьшаем его
        if width > max_dimension or height > max_dimension:
            ratio = min(max_dimension / width, max_dimension / height)
            new_width = int(width * ratio)
            new_height = int(height * ratio)
            image = image.resize((new_width, new_height), Image.LANCZOS)
            print(f"Изображение уменьшено с {width}x{height} до {new_width}x{new_height}")

        # Применяем улучшение контрастности для лучшего распознавания
        from PIL import ImageEnhance
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.2)  # Увеличиваем контраст на 20%

        enhancer = ImageEnhance.Sharpness(image)
        image = enhancer.enhance(1.3)  # Увеличиваем резкость на 30%

        # Сохраняем с высоким качеством
        image.save(buffered, format=format, quality=quality, optimize=True)

        # Получаем размер изображения в байтах
        image_size = buffered.tell()
        buffered.seek(0)

        # Если изображение всё ещё слишком большое, уменьшаем качество
        if image_size > 10 * 1024 * 1024:  # 10 МБ (увеличено для API Claude)
            print(f"Изображение слишком большое ({image_size / (1024 * 1024):.2f} МБ), уменьшаем качество")
            buffered = io.BytesIO()
            lower_quality = max(70, quality - 15)  # Не снижаем качество ниже 70%
            image.save(buffered, format=format, quality=lower_quality, optimize=True)
            image_size = buffered.tell()
            print(f"Новый размер: {image_size / (1024 * 1024):.2f} МБ")
            buffered.seek(0)

        # Кодируем в base64
        encoded = base64.b64encode(buffered.getvalue()).decode('utf-8')
        return encoded

    def is_food_related_document(self, image: Image.Image) -> bool:
        """
        Предварительная проверка, содержит ли документ информацию о продуктах питания

        Args:
            image (Image.Image): Изображение документа

        Returns:
            bool: True, если документ, вероятно, содержит информацию о продуктах
        """
        # Кодируем изображение в base64
        image_base64 = self.encode_image_to_base64(image, quality=75)  # Снижаем качество для быстроты

        # Системное сообщение для быстрой классификации документа
        system_message = """
        Ты - эксперт по классификации документов. Твоя задача - определить, является ли документ
        счетом/накладной на продукты питания или нет. Отвечай только 'YES' или 'NO'.
        """

        # Пользовательское сообщение с детальной инструкцией для классификации
        user_message = """
        Проанализируй изображение и ответь только 'YES' или 'NO':
        Является ли этот документ счетом, накладной или чеком за продукты питания (фрукты, овощи,
        мясо, рыба, хлеб, молочные продукты и т.д.)?

        Ответь 'YES', если документ содержит список продуктов питания с ценами или количеством.
        Ответь 'NO', если это:
        - Счет за парковку, транспорт, доставку
        - Таможенная декларация
        - Счет за непродовольственные товары (техника, оборудование, канцтовары и т.д.)
        - Финансовый или банковский документ
        - Любой другой документ, не содержащий список продуктов питания

        Важно: Ответь ТОЛЬКО 'YES' или 'NO', без дополнительных пояснений.
        """

        try:
            # Создаем запрос к API с ограничением на токены для быстрого ответа
            response = self.client.messages.create(
                model="claude-3-7-sonnet-20250219",
                max_tokens=10,  # Ограничиваем для быстрого ответа
                system=system_message,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": user_message
                            },
                            {
                                "type": "image",
                                "source": {
                                    "type": "base64",
                                    "media_type": "image/jpeg",
                                    "data": image_base64
                                }
                            }
                        ]
                    }
                ]
            )

            # Получаем ответ
            response_text = response.content[0].text.strip().upper()

            # Проверяем ответ
            if 'YES' in response_text:
                print("Документ содержит информацию о продуктах питания")
                return True
            else:
                print("Документ не содержит информацию о продуктах питания")
                self.skipped_count += 1  # Увеличиваем счетчик пропущенных документов
                return False

        except Exception as e:
            print(f"Ошибка при предварительной проверке документа: {e}")
            # В случае ошибки лучше обработать документ, чем пропустить
            return True

    def process_image_with_api(self, image: Image.Image, page_number: int) -> List[Dict]:
        """
        Отправляет изображение на обработку через API Claude
        с улучшенным запросом для распознавания счетов на иврите

        Args:
            image (Image.Image): Изображение для обработки
            page_number (int): Номер страницы

        Returns:
            List[Dict]: Результат обработки в виде списка продуктов
        """
        # Предварительная проверка, содержит ли документ информацию о продуктах
        if not self.is_food_related_document(image):
            print(f"Документ пропущен, так как не содержит информацию о продуктах питания")

            # Добавляем информацию в статистику
            self.page_statistics[page_number] = {
                "status": "skipped",
                "reason": "Документ не содержит информацию о продуктах питания",
                "products": []
            }

            return []

        # Кодируем изображение в base64
        image_base64 = self.encode_image_to_base64(image)

        # Улучшенное системное сообщение для оптимального распознавания счетов
        system_message = """
        Ты - эксперт по анализу счетов и накладных на иврите. Твоя задача - точно извлечь структурированные
        данные о продуктах питания из документа. Даже если документ содержит мало информации или имеет
        плохое качество, попытайся извлечь все возможные данные о продуктах.

        1. Ищи любую информацию о продуктах питания, даже если документ не похож на обычный чек
        2. Обрати внимание на строки с названиями продуктов, их ценами и количеством
        3. Часто цены могут быть указаны в формате XX.XX ₪ или ₪XX.XX
        4. Количество может быть указано в кг, л, шт или просто числом

        Возвращай структурированный результат даже если ты не уверен на 100% в правильности распознавания.
        """

        # Улучшенное пользовательское сообщение с детальной инструкцией
        user_message = """
        Проанализируй документ и извлеки все данные о продуктах питания. Необходимо:

        1. Найти все названия продуктов питания (на иврите)
        2. Определить цену каждого продукта (только число в шекелях)
        3. Определить количество каждого продукта (кг, л, шт)
        4. Перевести название каждого продукта на английский

        Результат представь в виде JSON в следующем формате:
        [
          {
            "product_name": "название продукта на иврите",
            "translated_name": "перевод на английский",
            "price": "цена (только число)",
            "quantity": "количество (только число)",
            "unit": "единица измерения (кг, л, шт)"
          },
          ...
        ]

        Важные моменты:
        - Если ты не можешь определить какое-то поле, оставь его пустым ("")
        - Даже если документ содержит только часть информации (например, только название и цену), включи эти данные
        - Если документ содержит сводную информацию или таблицу расходов, попытайся извлечь данные о продуктах
        - Если документ не содержит данных о продуктах, верни пустой массив []
        - Обрати внимание на все возможные места, где могут быть указаны продукты

        Ответ должен содержать ТОЛЬКО JSON массив, без дополнительного текста.
        """

        # Максимальное количество попыток при ошибках
        max_retries = 3
        retry_delay = 5  # секунды

        for attempt in range(max_retries):
            try:
                # Создаем запрос к API
                response = self.client.messages.create(
                    model="claude-3-7-sonnet-20250219",
                    max_tokens=4000,
                    system=system_message,
                    messages=[
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "text",
                                    "text": user_message
                                },
                                {
                                    "type": "image",
                                    "source": {
                                        "type": "base64",
                                        "media_type": "image/jpeg",
                                        "data": image_base64
                                    }
                                }
                            ]
                        }
                    ]
                )

                # Извлекаем текст из ответа
                response_text = response.content[0].text.strip()

                # Пытаемся извлечь JSON из ответа
                products = self.extract_products_from_response(response_text)

                # Добавляем номер страницы для каждого продукта
                for product in products:
                    product["page_number"] = page_number

                # Добавляем информацию в статистику
                self.page_statistics[page_number] = {
                    "status": "processed",
                    "products": products,
                    "count": len(products)
                }

                # Если удалось извлечь хотя бы один продукт, возвращаем результат
                if products:
                    return products

                # Если не удалось извлечь продукты из JSON, пробуем извлечь их из текста
                if attempt == max_retries - 1:
                    # На последней попытке пробуем извлечь продукты из текста напрямую
                    text_products = self.extract_products_from_text(response_text)

                    # Добавляем номер страницы для каждого продукта
                    for product in text_products:
                        product["page_number"] = page_number

                    # Обновляем статистику
                    self.page_statistics[page_number] = {
                        "status": "processed_from_text",
                        "products": text_products,
                        "count": len(text_products)
                    }

                    if text_products:
                        return text_products

            except Exception as e:
                print(f"Ошибка при обращении к API (попытка {attempt+1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    print(f"Повторная попытка через {retry_delay} секунд...")
                    time.sleep(retry_delay)

        # Если все попытки не удались, добавляем информацию в статистику
        self.page_statistics[page_number] = {
            "status": "failed",
            "reason": "Не удалось извлечь продукты из документа",
            "products": []
        }

        return []

    def extract_products_from_response(self, response_text: str) -> List[Dict]:
        """
        Улучшенный метод извлечения данных о продуктах из ответа API

        Args:
            response_text (str): Текст ответа от API

        Returns:
            List[Dict]: Список данных о продуктах
        """
        # Пытаемся извлечь JSON из ответа
        try:
            # Проверяем, содержит ли ответ блок кода JSON
            if "```json" in response_text and "```" in response_text:
                # Извлекаем JSON из блока кода
                json_start = response_text.find("```json") + 7
                json_end = response_text.find("```", json_start)
                json_content = response_text[json_start:json_end].strip()
                return json.loads(json_content)

            # Проверяем, начинается ли ответ с квадратной скобки (JSON массив)
            elif response_text.strip().startswith('[') and response_text.strip().endswith(']'):
                return json.loads(response_text)

            # Ищем JSON массив в тексте
            else:
                json_start = response_text.find('[')
                json_end = response_text.rfind(']') + 1

                if json_start >= 0 and json_end > json_start:
                    json_content = response_text[json_start:json_end]
                    return json.loads(json_content)

        except json.JSONDecodeError as e:
            print(f"Ошибка парсинга JSON: {e}")

        return []

    def extract_products_from_text(self, text: str) -> List[Dict]:
        """
        Извлекает данные о продуктах напрямую из текста, если не удалось извлечь JSON

        Args:
            text (str): Текст ответа от API

        Returns:
            List[Dict]: Список данных о продуктах
        """
        products = []

        # Ищем упоминания продуктов, цен и количества
        # Пример: находим строки, где упоминается продукт и цена
        product_pattern = r'([א-ת\s]+)[:\-]?\s*(\d+(?:[.,]\d+)?)(?:\s*₪|\s*שקל)'
        matches = re.findall(product_pattern, text)

        for match in matches:
            product_name = match[0].strip()
            price = match[1].replace(',', '.')

            # Ищем упоминание количества рядом с продуктом
            quantity_pattern = r'(\d+(?:[.,]\d+)?)\s*(?:קג|ק"ג|kg|כמות|יחידות|ליטר|l|שתיים|שלוש|ארבע)'
            quantity_match = re.search(quantity_pattern, text[text.find(product_name)-50:text.find(product_name)+150])

            quantity = ""
            unit = ""
            if quantity_match:
                quantity = quantity_match.group(1).replace(',', '.')
                unit_text = quantity_match.group(0)
                if 'קג' in unit_text or 'ק"ג' in unit_text or 'kg' in unit_text:
                    unit = 'kg'
                elif 'ליטר' in unit_text or 'l' in unit_text:
                    unit = 'l'
                else:
                    unit = 'pcs'

            # Добавляем продукт в список
            products.append({
                "product_name": product_name,
                "translated_name": self.translate_product_name(product_name),
                "price": price,
                "quantity": quantity,
                "unit": unit
            })

        return products

    def translate_product_name(self, product_name: str) -> str:
        """
        Переводит название продукта с иврита на английский

        Args:
            product_name (str): Название продукта на иврите

        Returns:
            str: Переведенное название продукта
        """
        # Используем существующий словарь соответствий
        if product_name in self.product_mapping:
            return self.product_mapping[product_name]

        # Если точного соответствия нет, ищем частичное
        for hebrew, english in self.product_mapping.items():
            if hebrew in product_name:
                return english

        # Если не нашли соответствия, возвращаем исходное название
        return product_name

    def process_large_pdf(self, pdf_path: str, pages_per_chunk: int = 5) -> List[Dict]:
        """
        Обрабатывает крупный PDF, разделяя его на части

        Args:
            pdf_path (str): Путь к PDF файлу
            pages_per_chunk (int): Количество страниц в каждой части

        Returns:
            List[Dict]: Объединенный список результатов обработки
        """
        # Создаем временную папку для частей PDF
        temp_dir = tempfile.mkdtemp()

        # Сбрасываем счетчик пропущенных документов
        self.skipped_count = 0

        try:
            # Разделяем PDF на части
            chunk_paths = self.split_pdf(pdf_path, temp_dir, pages_per_chunk)

            # Обрабатываем каждую часть
            all_results = []

            # Последовательная обработка для надежности
            for chunk_path in chunk_paths:
                try:
                    # Конвертируем PDF в изображения
                    images_with_pages = self.convert_pdf_to_images(chunk_path)

                    chunk_results = []
                    for i, (img, page_number) in enumerate(images_with_pages):
                        print(f"Обработка страницы {i+1}/{len(images_with_pages)} из файла {os.path.basename(chunk_path)}")

                        # Обрабатываем изображение через API с номером страницы
                        result = self.process_image_with_api(img, page_number)
                        if result:
                            # Если результат - список, то расширяем общий список
                            if isinstance(result, list):
                                chunk_results.extend(result)
                            # Если результат - словарь, то добавляем его как элемент
                            elif isinstance(result, dict):
                                chunk_results.append(result)

                    all_results.extend(chunk_results)
                    print(f"Завершена обработка части {os.path.basename(chunk_path)}")
                except Exception as e:
                    print(f"Ошибка при обработке части {os.path.basename(chunk_path)}: {e}")

            # Сохраняем все найденные продукты
            self.all_products = all_results

            # Выводим итоговую статистику
            self.print_statistics()

            return all_results

        finally:
            # Удаляем временные файлы
            for chunk_path in os.listdir(temp_dir):
                try:
                    os.remove(os.path.join(temp_dir, chunk_path))
                except:
                    pass
            try:
                os.rmdir(temp_dir)
            except:
                pass

    def print_statistics(self):
        """
        Выводит подробную статистику о обработанных страницах и найденных продуктах
        """
        print(f"\nИТОГОВАЯ СТАТИСТИКА:")
        print(f"Всего пропущено документов: {self.skipped_count}")

        print(f"\nНайденные продукты по страницам:")

        # Сортируем страницы по номеру
        sorted_pages = sorted(self.page_statistics.keys())

        for page_number in sorted_pages:
            page_stats = self.page_statistics[page_number]
            status = page_stats.get("status", "")

            if status == "skipped":
                print(f"  Страница {page_number}: Пропущена - {page_stats.get('reason', '')}")
            elif status == "failed":
                print(f"  Страница {page_number}: Ошибка обработки - {page_stats.get('reason', '')}")
            else:
                products = page_stats.get("products", [])
                if products:
                    print(f"  Страница {page_number}: Найдено {len(products)} продуктов:")
                    for i, product in enumerate(products, 1):
                        product_name = product.get("product_name", "")
                        translated_name = product.get("translated_name", "")
                        price = product.get("price", "")
                        quantity = product.get("quantity", "")
                        unit = product.get("unit", "")

                        product_info = f"    {i}. {product_name}"
                        if translated_name and translated_name != product_name:
                            product_info += f" ({translated_name})"

                        if price:
                            product_info += f" - цена: {price} ₪"

                        if quantity:
                            product_info += f", количество: {quantity}"
                            if unit:
                                product_info += f" {unit}"

                        print(product_info)
                else:
                    print(f"  Страница {page_number}: Продукты не найдены")

    def fuzzy_match_product(self, product_name: str, product_list: List[str], threshold: int = 70) -> Optional[str]:
        """
        Выполняет нечеткое сопоставление названия продукта с списком продуктов

        Args:
            product_name (str): Название продукта для сопоставления
            product_list (List[str]): Список продуктов для сопоставления
            threshold (int): Порог сходства (0-100)

        Returns:
            Optional[str]: Наиболее похожее название или None, если порог не преодолен
        """
        # Перевод с иврита на английский, если есть в маппинге
        if product_name in self.product_mapping:
            product_name = self.product_mapping[product_name]

        # Проверка на прямое совпадение
        for product in product_list:
            if product.lower() == product_name.lower():
                return product

        # Нечеткое сопоставление
        best_match = process.extractOne(product_name, product_list)
        if best_match and best_match[1] >= threshold:
            return best_match[0]

        # Поиск слов из названия продукта в списке продуктов
        product_words = product_name.lower().split()
        for product in product_list:
            product_lower = product.lower()
            matching_words = sum(1 for word in product_words if word in product_lower)
            if matching_words >= min(2, len(product_words)):
                return product

        return None

    def update_excel_with_results(self, excel_path: str, recognition_results: List[Dict]) -> str:
        """
        Обновляет Excel таблицу, добавляя распознанные названия продуктов и цены.
        Также создает новый лист со всеми обнаруженными продуктами.

        Args:
            excel_path (str): Путь к Excel файлу
            recognition_results (List[Dict]): Результаты распознавания

        Returns:
            str: Путь к обновленному Excel файлу
        """
        # Загружаем Excel файл
        df = pd.read_excel(excel_path)

        # Получаем список продуктов из колонки A (названия продуктов)
        product_names = df['Product Name'].dropna().tolist() if 'Product Name' in df.columns else []
        if not product_names and len(df.columns) > 0:
            # Если нет колонки 'Product Name', берем первую колонку
            product_names = df.iloc[:, 0].dropna().tolist()

        # Создаем лог для отчета
        matching_log = []

        # Обрабатываем результаты распознавания
        for result in recognition_results:
            # Извлекаем данные о продукте
            original_name = result.get('product_name', '')
            translated_name = result.get('translated_name', '')
            unit_price = result.get('price', '')
            quantity = result.get('quantity', '')
            unit = result.get('unit', '')

            # Для обратной совместимости с предыдущей версией
            if not original_name and 'original_name' in result:
                original_name = result['original_name']
            if not translated_name and 'translated_name' in result:
                translated_name = result['translated_name']
            if not unit_price and 'unit_price' in result:
                unit_price = result['unit_price']
            if not quantity and 'quantity' in result:
                quantity = result['quantity']
            if not unit and 'unit' in result:
                unit = result['unit']

            # Очищаем цену и количество от нечисловых символов
            try:
                # Обработка цены
                if isinstance(unit_price, str):
                    unit_price = re.sub(r'[^\d.,]', '', unit_price).replace(',', '.')
                    unit_price = float(unit_price) if unit_price else None

                # Обработка количества
                if isinstance(quantity, str):
                    quantity = re.sub(r'[^\d.,]', '', quantity).replace(',', '.')
                    quantity = float(quantity) if quantity else None
            except Exception as e:
                print(f"Ошибка при обработке цены/количества для {original_name}: {e}")
                unit_price = None
                quantity = None

            # Ищем соответствие с продуктами в Excel
            match_found = False

            # Пробуем сначала сопоставить по переведенному названию
            match_name = None
            if translated_name:
                match_name = self.fuzzy_match_product(translated_name, product_names)

            # Если не удалось, пробуем сопоставить по оригинальному названию
            if not match_name and original_name:
                match_name = self.fuzzy_match_product(original_name, product_names)

            # Если найдено соответствие, обновляем данные в Excel
            if match_name:
                match_found = True
                match_index = df[df.iloc[:, 0] == match_name].index.tolist()

                if match_index:
                    row_idx = match_index[0]

                    # Обновляем название продукта в колонке J (индекс 9)
                    if original_name and 9 < df.shape[1]:
                        df.iloc[row_idx, 9] = original_name

                    # Обновляем цену в колонке K (индекс 10)
                    if unit_price is not None and 10 < df.shape[1]:
                        df.iloc[row_idx, 10] = unit_price

                    # Добавляем информацию в лог
                    matching_log.append({
                        "status": "matched",
                        "original_name": original_name,
                        "translated_name": translated_name,
                        "matched_with": match_name,
                        "unit_price": unit_price,
                        "quantity": quantity,
                        "unit": unit
                    })
                else:
                    matching_log.append({
                        "status": "match_name_found_but_no_row",
                        "original_name": original_name,
                        "translated_name": translated_name,
                        "matched_with": match_name,
                        "unit_price": unit_price,
                        "quantity": quantity,
                        "unit": unit
                    })
            else:
                matching_log.append({
                    "status": "no_match_found",
                    "original_name": original_name,
                    "translated_name": translated_name,
                    "unit_price": unit_price,
                    "quantity": quantity,
                    "unit": unit
                })

        # Создаем новый лист с данными о всех обнаруженных продуктах
        all_products_data = []

        for result in recognition_results:
            product_name = result.get('product_name', '') or result.get('original_name', '')
            translated_name = result.get('translated_name', '')
            unit_price = result.get('price', '') or result.get('unit_price', '')
            quantity = result.get('quantity', '')
            unit = result.get('unit', '')
            page_number = result.get('page_number', '')

            # Преобразуем в числа, если возможно
            try:
                if isinstance(unit_price, str):
                    unit_price = float(re.sub(r'[^\d.,]', '', unit_price).replace(',', '.'))
                if isinstance(quantity, str):
                    quantity = float(re.sub(r'[^\d.,]', '', quantity).replace(',', '.'))
            except:
                pass

            all_products_data.append({
                "Товар": product_name,
                "Товар (перевод)": translated_name,
                "Количество": quantity,
                "Единица": unit,
                "Цена": unit_price,
                "Страница": page_number
            })

        # Создаем DataFrame для нового листа
        if all_products_data:
            all_products_df = pd.DataFrame(all_products_data)
        else:
            # Если не найдено продуктов, создаем пустой DataFrame с нужными колонками
            all_products_df = pd.DataFrame(columns=["Товар", "Товар (перевод)", "Количество", "Единица", "Цена", "Страница"])

        # Создаем путь для сохранения обновленного Excel файла
        base_name, ext = os.path.splitext(excel_path)
        output_path = f"{base_name}_updated{ext}"

        # Сохраняем обновленный Excel файл с новым листом
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            # Сохраняем обновленный основной лист
            df.to_excel(writer, index=False, sheet_name='Original')

            # Сохраняем новый лист со всеми продуктами
            all_products_df.to_excel(writer, index=False, sheet_name='Все продукты')

        # Создаем отчет о сопоставлении
        log_df = pd.DataFrame(matching_log)
        log_path = f"{base_name}_matching_log.xlsx"
        log_df.to_excel(log_path, index=False)

        print(f"Обновленная таблица сохранена в {output_path}")
        print(f"Создан новый лист 'Все продукты' с данными о {len(all_products_data)} товарах")
        print(f"Лог сопоставления сохранен в {log_path}")

        return output_path

def process_invoice_and_update_excel():
    """
    Загружает PDF счет и Excel таблицу, обрабатывает счет и обновляет таблицу
    """
    # Запрашиваем API ключ
    api_key = input("Введите ваш API ключ Anthropic: ")

    # Запрашиваем количество страниц в каждой части
    pages_per_chunk = input("\nВведите количество страниц для обработки в каждой части (рекомендуется 5-10): ")
    try:
        pages_per_chunk = int(pages_per_chunk)
        if pages_per_chunk < 1:
            pages_per_chunk = 5
    except:
        pages_per_chunk = 5

    print(f"\nКаждая часть PDF будет содержать до {pages_per_chunk} страниц.")

    # Загружаем PDF счет
    print("\nВыберите PDF файл счета для обработки:")
    uploaded_pdf = files.upload()

    if not uploaded_pdf:
        print("PDF файл не был загружен. Операция отменена.")
        return

    pdf_path = list(uploaded_pdf.keys())[0]

    # Загружаем Excel таблицу
    print("\nВыберите Excel файл для обновления:")
    uploaded_excel = files.upload()

    if not uploaded_excel:
        print("Excel файл не был загружен. Операция отменена.")
        return

    excel_path = list(uploaded_excel.keys())[0]

    # Создаем процессор счетов
    processor = EnhancedInvoiceProcessor(api_key)

    try:
        # Обрабатываем PDF счет
        print(f"\nНачинаем обработку PDF счета: {pdf_path}")
        recognition_results = processor.process_large_pdf(pdf_path, pages_per_chunk)

        if not recognition_results:
            print("Не удалось извлечь данные из счета. Проверьте PDF файл и попробуйте снова.")
            return

        print(f"Извлечено {len(recognition_results)} позиций из счета.")

        # Обновляем Excel таблицу с результатами распознавания
        print(f"\nОбновляем Excel таблицу: {excel_path}")
        updated_excel_path = processor.update_excel_with_results(excel_path, recognition_results)

        # Предлагаем скачать обновленную таблицу
        try:
            files.download(updated_excel_path)
            print(f"Файл {updated_excel_path} готов к скачиванию")

            # Получаем имя лог-файла
            base_name, ext = os.path.splitext(excel_path)
            log_path = f"{base_name}_matching_log.xlsx"

            # Предлагаем скачать лог сопоставления
            files.download(log_path)
            print(f"Файл {log_path} готов к скачиванию")
        except Exception as e:
            print(f"Ошибка при скачивании файла: {e}")
            print(f"Вы можете найти результаты в файлах {updated_excel_path} и {log_path} на вашем Google Диске")

    except Exception as e:
        print(f"Ошибка при обработке: {e}")

# Запускаем функцию при выполнении скрипта
if __name__ == "__main__":
    process_invoice_and_update_excel()